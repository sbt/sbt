import Dependencies._
import Util._
import com.typesafe.tools.mima.core._, ProblemFilters._

ThisBuild / git.baseVersion := "1.3.0"
ThisBuild / version := {
  val old = (ThisBuild / version).value
  nightlyVersion match {
    case Some(v) => v
    case _ =>
      if (old contains "SNAPSHOT") git.baseVersion.value + "-SNAPSHOT"
      else old
  }
}

def internalPath = file("internal")

def commonSettings: Seq[Setting[_]] = Seq(
  scalaVersion := scala212,
  // publishArtifact in packageDoc := false,
  resolvers += Resolver.typesafeIvyRepo("releases"),
  resolvers += Resolver.sonatypeRepo("snapshots"),
  resolvers += Resolver.mavenLocal,
  // concurrentRestrictions in Global += Util.testExclusiveRestriction,
  testOptions += Tests.Argument(TestFrameworks.ScalaCheck, "-w", "1"),
  javacOptions in compile ++= Seq("-Xlint", "-Xlint:-serial"),
  crossScalaVersions := Seq(scala212, scala213),
  scalacOptions in console in Compile -= "-Ywarn-unused-import",
  scalacOptions in console in Test -= "-Ywarn-unused-import",
  publishArtifact in Compile := true,
  publishArtifact in Test := false
)

val mimaSettings = Def settings (
  mimaPreviousArtifacts := Set(
    "1.0.0", "1.0.1", "1.0.2", "1.0.3",
    "1.1.0", "1.1.1", "1.1.2", "1.1.3",
    "1.2.0", "1.2.1"
  ) map (version =>
    organization.value %% moduleName.value % version
      cross (if (crossPaths.value) CrossVersion.binary else CrossVersion.disabled)
  ),
)

lazy val utilRoot: Project = (project in file("."))
  .aggregate(
    utilInterface,
    utilControl,
    utilPosition,
    utilLogging,
    utilRelation,
    utilCache,
    utilTracking,
    utilScripted
  )
  .settings(
    inThisBuild(
      Seq(
        bintrayPackage := "util",
        homepage := Some(url("https://github.com/sbt/util")),
        description := "Util module for sbt",
        scmInfo := Some(ScmInfo(url("https://github.com/sbt/util"), "git@github.com:sbt/util.git")),
      )),
    commonSettings,
    name := "Util Root",
    publish / skip := true,
    customCommands
  )

// defines Java structures used across Scala versions, such as the API structures and relationships extracted by
//   the analysis compiler phases and passed back to sbt.  The API structures are defined in a simple
//   format from which Java sources are generated by the datatype generator Projproject
lazy val utilInterface = (project in internalPath / "util-interface").settings(
  commonSettings,
  javaOnlySettings,
  name := "Util Interface",
  exportJars := true,
  mimaSettings,
)

lazy val utilControl = (project in internalPath / "util-control").settings(
  commonSettings,
  name := "Util Control",
  mimaSettings,
)

val utilPosition = (project in file("internal") / "util-position")
  .settings(
    commonSettings,
    name := "Util Position",
    scalacOptions += "-language:experimental.macros",
    libraryDependencies ++= Seq(scalaReflect.value, scalaTest),
    mimaSettings,
  )

lazy val utilLogging = (project in internalPath / "util-logging")
  .enablePlugins(ContrabandPlugin, JsonCodecPlugin)
  .dependsOn(utilInterface)
  .settings(
    commonSettings,
    name := "Util Logging",
    libraryDependencies ++=
      Seq(jline, log4jApi, log4jCore, disruptor, sjsonnewScalaJson.value, scalaReflect.value),
    libraryDependencies ++= Seq(scalaCheck, scalaTest),
    libraryDependencies ++= (scalaVersion.value match {
      case v if v.startsWith("2.12.") => List(compilerPlugin(silencerPlugin))
      case _                          => List()
    }),
    Compile / scalacOptions ++= (scalaVersion.value match {
      case v if v.startsWith("2.12.") => List("-Ywarn-unused:-locals,-explicits,-privates")
      case _                          => List()
    }),
    sourceManaged in (Compile, generateContrabands) := baseDirectory.value / "src" / "main" / "contraband-scala",
    contrabandFormatsForType in generateContrabands in Compile := { tpe =>
      val old = (contrabandFormatsForType in generateContrabands in Compile).value
      val name = tpe.removeTypeParameters.name
      if (name == "Throwable") Nil
      else old(tpe)
    },
    mimaSettings,
    mimaBinaryIssueFilters ++= Seq(
      exclude[DirectMissingMethodProblem]("sbt.internal.util.SuccessEvent.copy*"),
      exclude[DirectMissingMethodProblem]("sbt.internal.util.TraceEvent.copy*"),
      exclude[DirectMissingMethodProblem]("sbt.internal.util.StringEvent.copy*"),
      // Private final class constructors changed
      exclude[DirectMissingMethodProblem]("sbt.util.InterfaceUtil#ConcretePosition.this"),
      exclude[DirectMissingMethodProblem]("sbt.util.InterfaceUtil#ConcreteProblem.this"),
      exclude[ReversedMissingMethodProblem]("sbt.internal.util.ConsoleOut.flush"),
      // This affects Scala 2.11 only it seems, so it's ok?
      exclude[InheritedNewAbstractMethodProblem]("sbt.internal.util.codec.JsonProtocol.LogOptionFormat"),
      exclude[InheritedNewAbstractMethodProblem]("sbt.internal.util.codec.JsonProtocol.ProgressItemFormat"),
      exclude[InheritedNewAbstractMethodProblem]("sbt.internal.util.codec.JsonProtocol.ProgressEventFormat"),
    ),
  )
  .configure(addSbtIO)

lazy val utilRelation = (project in internalPath / "util-relation")
  .settings(
    commonSettings,
    name := "Util Relation",
    libraryDependencies ++= Seq(scalaCheck),
    mimaSettings,
  )

// Persisted caching based on sjson-new
lazy val utilCache = (project in file("util-cache"))
  .settings(
    commonSettings,
    name := "Util Cache",
    libraryDependencies ++=
      Seq(sjsonnewScalaJson.value, sjsonnewMurmurhash.value, scalaReflect.value),
    libraryDependencies ++= Seq(scalaTest),
    mimaSettings,
    mimaBinaryIssueFilters ++= Seq(
      // These are private case classes that have changed
      exclude[IncompatibleMethTypeProblem]("sbt.util.FileHashModified.apply"),
      exclude[IncompatibleResultTypeProblem]("sbt.util.FileHashModified.copy$default$2"),
      exclude[IncompatibleMethTypeProblem]("sbt.util.FileHashModified.copy"),
      exclude[IncompatibleMethTypeProblem]("sbt.util.FileHashModified.this"),
      exclude[IncompatibleMethTypeProblem]("sbt.util.FileHash.apply"),
      exclude[IncompatibleResultTypeProblem]("sbt.util.FileHash.copy$default$2"),
      exclude[IncompatibleMethTypeProblem]("sbt.util.FileHash.copy"),
      exclude[IncompatibleMethTypeProblem]("sbt.util.FileHash.this"),
      // Added a method to a sealed trait, technically not a problem for Scala
      exclude[ReversedMissingMethodProblem]("sbt.util.HashFileInfo.hashArray"),
    )
  )
  .configure(addSbtIO)

// Builds on cache to provide caching for filesystem-related operations
lazy val utilTracking = (project in file("util-tracking"))
  .dependsOn(utilCache)
  .settings(
    commonSettings,
    name := "Util Tracking",
    libraryDependencies ++= Seq(scalaTest),
    mimaSettings,
  )
  .configure(addSbtIO)

lazy val utilScripted = (project in internalPath / "util-scripted")
  .dependsOn(utilLogging, utilInterface)
  .settings(
    commonSettings,
    name := "Util Scripted",
    libraryDependencies += parserCombinator,
    mimaSettings,
  )
  .configure(addSbtIO)

def customCommands: Seq[Setting[_]] = Seq(
  commands += Command.command("release") { state =>
    // "clean" ::
    "+compile" ::
      "+publishSigned" ::
      "reload" ::
      state
  }
)

inThisBuild(Seq(
  whitesourceProduct                   := "Lightbend Reactive Platform",
  whitesourceAggregateProjectName      := "sbt-util-master",
  whitesourceAggregateProjectToken     := "b9b11b2f43d34c44b28d8922624eef07a3f1b20d95ad45a5b5d973513ab173f4",
  whitesourceIgnoredScopes             += "scalafmt",
  whitesourceFailOnError               := sys.env.contains("WHITESOURCE_PASSWORD"), // fail if pwd is present
  whitesourceForceCheckAllDependencies := true,
))
